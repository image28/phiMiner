/* Based on code from https://community.amd.com/t5/opencl/clutil-a-library-for-making-opencl-as-easy-to-use-as-cuda/m-p/388306/ */

#define CL_TARGET_OPENCL_VERSION 120

// From https://eth.wiki/en/concepts/ethash/ethash
#define WORD_BYTES 4                 // bytes in word
#define DATASET_BYTES_INIT powl(2,30)     // bytes in dataset at genesis
#define DATASET_BYTES_GROWTH powl(2,23)   // dataset growth per epoch
#define CACHE_BYTES_INIT powl(2,24)       // bytes in cache at genesis
#define CACHE_BYTES_GROWTH powl(2,17)     // cache growth per epoch
#define CACHE_MULTIPLIER 1024          // Size of the DAG relative to the cache
#define EPOCH_LENGTH 30000           // blocks per epoch
#define MIX_BYTES 128                // width of mix
#define HASH_BYTES 64                // hash length in bytes
#define DATASET_PARENTS 256          // number of parents of each dataset element
#define CACHE_ROUNDS 3               // number of rounds in cache production
#define ACCESSES 64                  // number of accesses in hashimoto loop
// From https://eth.wiki/en/concepts/ethash/ethash

#define WORKSIZE 256

#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <pthread.h>
#include <unistd.h>
#include <CL/cl.h>
#include <math.h>
#include "ethash.h"
#include "data_sizes.h"

typedef uint16_t uint16;
typedef uint32_t uint32;
typedef uint64_t uint64;

const static uint32_t zerox3[3] = {0, 0, 0};

#define c_maxSearchResults 4

struct __attribute__((packed)) __attribute__((aligned(128))) SearchResults {
    uint32_t count;
    uint32_t hashCount;
    uint32_t abort;
    uint32_t gid[c_maxSearchResults];
};

/* If a string needs to be split multiple times and wont exceed 65535 characters
   and the splits wont be within one character boundries of each other
   store the start and end split adresses at 0 start and +1 end */
struct boundedString
{
	char *start;
	char *end;
};

#define MTU 1500
// Autogenerated prototypes
#include "main.h"
	/*prepend(code, "WORKSIZE", clGroupSize);
    prepend(code, "ACCESSES", 64);
    prepend(code, "MAX_OUTPUTS", c_maxSearchResults);
    prepend(code, "PLATFORM", static_cast<unsigned>(clPlatformType));
    prepend(code, "COMPUTE", computeCapability);*/



#define MAIN
#define PROFILING

#ifdef MAIN
int main(int argc, char *argv[])
{
#else
int worker(int argc, char *argv[])
{
#endif
	unsigned int length = 0;
	uint16 _Cache;
	uint16 _DAG0;
	uint16 _DAG1;
	uint64_t light_size;
	
	int count=0;
	char temp;
	size_t global;
	size_t local = 64;
	// remove hardcoding later
	const size_t workItems = 64; // GPU computes partial 512-bit DAG items.
	uint32_t m_block_multiple = 200000;
	const size_t clGroupSize=64;
	unsigned int clLocalSize=64;
	uint32_t start;
	const size_t chunk = workItems/clLocalSize;
	char nonce_text[7];
	struct SearchResults results;
	char header_hash[1024];
	char prev_seed_hash[1024];
	char seed_hash[1024];
	char jobid[1024];
	char id[64];
	uint8_t seedlen=17;
	double target=0;
	uint64_t startNonce=0;
	uint64_t dag_size=0;
	char dif_text[8];
	int fd;
	char buf[1024];
	char args[8][1024];
	uint8_t first=1;
	double tempTarget;
	char jobString;
	char uniqueId[33];
	int fred=0;

	cl_context context;
	cl_device_id devices[255];
	cl_device_id device;
	// Opencl vars
	
	cl_int err[1024];

	
	cl_command_queue commandQueue;
	
	cl_kernel kernels[2];
   	cl_mem m_searchBuffer,m_header,m_light,m_dag;
   	uint32_t s_light;
#ifdef PROFILE
	cl_event profileEvent;
#endif

    //Initialization
    uint8_t e,l;
    uint64_t epoch=411;
	char buffer[MTU];
	
    init_opencl(&context, &commandQueue, &devices[0], &device, err);
    load_kernels(&context, &commandQueue, &device, &kernels[0], err);
    
	// use netcat to get and submit work untill
	// I can get sockets working with raw packets
	// then switch bellow string split lines to
	// grab data from packets.
	// set the buffersize to the systems mtu
	// may improve latency in getting work to the opencl
	// code
	fd=open(".workpipe",O_APPEND);

	get_buffer(fd, &buffer[0]);
	check_string(buffer,&uniqueId[0],'"','"',48,81); // uniqueId
	check_string(buffer,&uniqueId[0],'"','"',108,105); // nonce
	check_double_not(buffer,&tempTarget,'[',']',53,62,53,62); // target diff

	temp='\0';
	count=0;
	buf[0]='\0';
	while(1)
	{
		get_buffer(fd, &buffer[0]);

		check_string_not(buffer,&jobString,'"','"',46,63,46,63); // jobid
		check_string_not(buffer,&seed_hash[0],'"','"',65,130,65,130);
		if (prev_seed_hash[0]='\0')
			strncpy(prev_seed_hash,seed_hash,65);

		//check_epoch();
		check_string_not(buffer,&header_hash[0],'"','"',132,197,132,197); // hash header

		if ( ! fred ) //( havejob ) &&
		{
			//hash();
		}else{
			check_double_not(buffer,&tempTarget,'[',']',53,62,52,62); // target diff
			if ( fred )	// Check if it the workloops first run
			{
				//cl_kernel *m_dagKernel, uint16_t epoch, cl_context context, cl_command_queue commandQueue,struct SearchResults *results ,cl_mem *m_searchBuffer, cl_mem *m_header,char *header_hash, char *seed_hash, cl_mem *m_light,cl_mem *m_dag,uint32_t *s_light,cl_int *err
				setup_dag_kernel(&kernels[0], epoch, context, commandQueue, &results, &m_searchBuffer, &m_header, &header_hash, &seed_hash, &m_light, &m_dag, &s_light, &err);
				// (cl_kernel *m_dagKernel,cl_command_queue commandQueue, struct SearchResults *results ,cl_mem *m_searchBuffer, cl_mem *m_light, cl_mem *m_dag, cl_mem *s_light, cl_int *err)
				run_dag_kernel(&kernels[0], commandQueue, &results, &m_searchBuffer,  &m_light, &m_dag, &s_light, &err);
			}
		}

		temp='\0';
		count=0;
		buf[0]='\0';
	}

	close(fd);
	//free(result);
	return(0);
}

void init_opencl(cl_context *context, cl_command_queue *commandQueue, cl_device_id *devices, cl_device_id *device, cl_int *err)
{
	cl_platform_id platform[255];
    cl_uint num_platforms;
	cl_uint num_devices;
    char info[1024];
    size_t info_length;
	int errorCount=0;
	int e,l;
	
    *(err+errorCount) = clGetPlatformIDs(255, platform, &num_platforms);
	errorCount=1;
    for(e=0; e < num_platforms; e++)
    {
   		clGetDeviceIDs(platform[e], CL_DEVICE_TYPE_ALL, num_platforms, devices, &num_devices);
    	for(l=0; l < num_devices; l++)
    	{
    		printf("%d-%d ",e,l);
    		*(err+errorCount)=clGetDeviceInfo(*(devices+l),CL_DEVICE_NAME,1024, &info, &info_length);
    		*(info+info_length)='\0';
    		printf("%s\n",info);
			errorCount++;
	    }
    }

    clGetDeviceIDs(*(platform+1), CL_DEVICE_TYPE_ALL, num_platforms, devices, &num_devices);
    *(device)=*(devices);
    *(context) = clCreateContext(NULL, 1, device, NULL, NULL, err+errorCount);
    *(commandQueue) = clCreateCommandQueue(*(context), *(device), 0, err+errorCount+1);
	print_errors("opencl init\0",errorCount+2,err);
}

void load_kernels(cl_context *context, cl_command_queue *commandQueue, cl_device_id *device, cl_kernel *kernels, cl_int *err)
{
	cl_program program;
	//cl_program *progPointer;
	int binary;
	
	if ( ( binary=open("ethash.bin",O_RDONLY) ) == 0 ) 
	{
		unsigned char *buffer;
		long binary_size;
		binary_size=lseek(binary,0L,2);
		lseek(binary,0L,0);
		buffer=malloc(binary_size);		
		read(binary,&buffer,binary_size);

		program = clCreateProgramWithBinary(*(context), 1, device, &binary_size, (const unsigned char **)buffer, NULL, err);
		close(binary);
		binary='\0';
		free(buffer);
		
		print_errors("Load Binary\0",1,err);
	}else{
		build_kernel(context,commandQueue,&program, device,err);
	}
	 
	*(kernels) = clCreateKernel(program, "GenerateDAG", err);
	*(kernels+1) = clCreateKernel(program, "search", err);
	print_errors("Load Kernels\0",3,err);
}

void build_kernel(cl_context *context, cl_command_queue *commandQueue, cl_program *program, cl_device_id *device, cl_int *err)
{
	const char *source=&kernelSource[0];
	
	/*="__kernel void kmain(__global int *out) {\n"
    "    out[get_global_id(0)]++;\n"
    "}\n\0"
;*/
    
     //
	char *result;
    size_t result_size;
    int binary;
    size_t binary_size;
    size_t max_size=32000000;
	result=malloc(max_size);
	
    *(program) = clCreateProgramWithSource(*(context), 1, &source, NULL, err);
    *(err+1)=clBuildProgram(*(program), (cl_uint)0, NULL, NULL, NULL, NULL);
	*(err+2)=clGetProgramBuildInfo(*(program),*(device),CL_PROGRAM_BUILD_LOG,max_size,result,&result_size);
	print_errors("Compiled opencl kernel\0",3,err);
	printf("%s\n", (char*)result);
	
	binary=open("ethash-compile.log",O_WRONLY | O_CREAT | O_TRUNC | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
    write(binary,result,result_size);
    close(binary);
    binary='\0';
	
    *(err+2)=clGetProgramInfo(*(program), CL_PROGRAM_BINARY_SIZES, sizeof(size_t), &binary_size, NULL);
    binary=open("ethash.bin",O_WRONLY | O_CREAT | O_TRUNC | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
    write(binary,program,binary_size);
    close(binary);
    free(result);
    
    print_errors("Compile binary\0",3,err);
}

#ifdef PROFILING
/* Code dervied from https://stackoverflow.com/questions/23550912/measuring-execution-time-of-opencl-kernels */
void setup_kernel_profiler(cl_command_queue queue, cl_kernel kernel, cl_event event, int woridim, int workgroupsize, cl_int *err)
{
	//*(err)=clEnqueueNDRangeKernel(queue, kernel, woridim, NULL, &workgroupsize, NULL, 0, NULL, &event);
}

void calculate_execution_time(cl_command_queue queue, cl_kernel kernel, cl_event event, int woridim, int workgroupsize)
{
	clWaitForEvents(1, &event);
	clFinish(queue);
	
	cl_ulong time_start;
	cl_ulong time_end;

	clGetEventProfilingInfo(event, CL_PROFILING_COMMAND_START, sizeof(time_start), &time_start, NULL);
	clGetEventProfilingInfo(event, CL_PROFILING_COMMAND_END, sizeof(time_end), &time_end, NULL);

	double nanoSeconds = time_end-time_start;
	printf("OpenCl Execution time is: %0.3f milliseconds \n",nanoSeconds / 1000000.0);
}

/* Code dervied from https://stackoverflow.com/questions/23550912/measuring-execution-time-of-opencl-kernels */
#endif

void get_buffer(int fd, char *buf)
{
	int count=0;
	char temp='\0';
	do
	{
		count=0;
		*(buf+0)='\0';
		temp='\0';

		read(fd, &temp, 1);
		if ( temp != '\0' )
		{
			
			*(buf+count)=temp;
			count++;
			*(buf+count)='\0';
		}
	}while ( ( temp != '\n' ) && ( count < 1023 ) );
}

void check_string_not(char buf[MTU], char *result, char start, char end, int start_pos, int end_pos, int not_start, int not_end)
{
	if ( ( buf[not_start] != '\0' ) && ( buf[not_end] != '\0' ) )
	{
		check_string(buf,result,start,end,start_pos,end_pos);
	}
}

void check_string(char buf[MTU], char *result, char start, char end, int start_pos, int end_pos)
{
	struct boundedString name;
	name.start=&buf[start_pos];
	name.end=&buf[end_pos];
	int length=end_pos-start_pos+1;

	if ( ( *(name.start) == start ) && ( *(name.end) == end ) )
	{
		name.start=&buf[start_pos+1];
		*(name.end)='\0';
		strncpy(result,name.start,length);
		*(result+length+1)='\0';
	}
}

void check_double_not(char buf[MTU], double *result, char start, char end, int start_pos, int end_pos, int not_start, int not_end)
{
	if ( ( buf[not_start] != '\0' ) && ( buf[not_end] != '\0' ) )
	{
		check_double(buf,result,start,end,start_pos,end_pos);
	}
}

void check_double(char buf[MTU], double *result, char start, char end, int start_pos, int end_pos)
{
	struct boundedString name;
	name.start=&buf[start_pos];
	name.end=&buf[end_pos];
	int length=end_pos-start_pos+1;

	if ( ( *(name.start) == start ) && ( *(name.end) == end ) )
	{
		name.start=&buf[start_pos+1];
		*(name.end)='\0';
		*(result)=strtod(name.start, NULL);
		*(result+length+1)='\0';
	}
}

/*
void check_epoch()
{
		if ( seed_hash[0] != prev_seed_hash[0] )
		{
				// EPOCH change detected
				exit(-1);
		}
}*/


void setup_dag_kernel(cl_kernel *m_dagKernel, uint16_t epoch, cl_context context, cl_command_queue commandQueue,struct SearchResults *results , cl_mem *m_searchBuffer, cl_mem *m_header, char *header_hash, char *seed_hash, cl_mem *m_light, cl_mem *m_dag,uint32_t *s_light,cl_int *err)
{
	int errorCount=0;
	uint32_t light_size=cache_sizes[epoch];
	uint32_t dag_size=((dag_sizes[epoch]/32)*32)+32;
	uint16_t workItems=WORKSIZE;
	light_size=((light_size/32)*32)+32;
	*(s_light)=light_size/64;
	uint8_t chunk=64;
	uint8_t start=0;
	
	// Search Buffer
	m_searchBuffer = clCreateBuffer(context, CL_MEM_WRITE_ONLY, sizeof(struct SearchResults), &results, *(err+errorCount+1));
	*(err+errorCount+1)=clEnqueueWriteBuffer(commandQueue, *(m_searchBuffer), CL_FALSE, 0, sizeof(zerox3), zerox3,0, NULL,NULL);
	m_header = clCreateBuffer(context, CL_MEM_READ_ONLY, 32, NULL, *(err+errorCount+2)); //|CL_MEM_ALLOC_HOST_PTR
	*(err+errorCount+3)=clEnqueueWriteBuffer(commandQueue, *(m_header), CL_TRUE, 0, 32, &header_hash, 0, NULL, NULL);
	m_light = clCreateBuffer(context, CL_MEM_READ_ONLY, light_size, NULL, *(err+errorCount+4));
	*(err+errorCount+5)=clEnqueueWriteBuffer(commandQueue, *(m_light), CL_TRUE, 0, *(s_light), &seed_hash, 0, NULL, NULL);
	m_dag = clCreateBuffer(context, CL_MEM_READ_ONLY, dag_size, NULL,*(err+errorCount+6));
	errorCount=errorCount+6;

	for (start = 0; start <= workItems - chunk; start += chunk) {
		const size_t offset=start;
		*(err+errorCount)=clSetKernelArg(*(m_dagKernel),0, 4, &start);
		*(err+errorCount+1)=clEnqueueNDRangeKernel(commandQueue, *(m_dagKernel), 1, &offset, &workItems, &chunk,0,NULL,NULL);
		*(err+errorCount+2)=clFlush(commandQueue);
		*(err+errorCount+3)=clFinish(commandQueue);
		errorCount=errorCount+4;
	}

	if (start < workItems) {
		const size_t offset=workItems - start;
		*(err+errorCount)=clSetKernelArg(*(m_dagKernel),0, 4, &start);
		*(err+errorCount+1)=clEnqueueNDRangeKernel(commandQueue, *(m_dagKernel), 1, &offset, &workItems, &chunk, 0, NULL,NULL);
		*(err+errorCount+2)=clFinish(commandQueue);
	}
	print_errors("Build dag kernel\0",errorCount+3,err);
}

void run_dag_kernel(cl_kernel *m_dagKernel,cl_command_queue commandQueue, struct SearchResults *results ,cl_mem *m_searchBuffer, cl_mem *m_light, cl_mem *m_dag, cl_mem *s_light, cl_int *err)
{
	int errorCount=0;
	*(err+errorCount)=clSetKernelArg(*(m_dagKernel),0, 8, *(m_light));
	*(err+errorCount+1)=clSetKernelArg(*(m_dagKernel),1, 8, *(m_dag));
	*(err+errorCount+2)=clSetKernelArg(*(m_dagKernel),2, 8, NULL);
	*(err+errorCount+3)=clSetKernelArg(*(m_dagKernel),3, 4, *(s_light));
	*(err+errorCount)=clFinish(commandQueue);
	print_errors("Run dag kernel\0",4,err);
	
}
/*
hash()
{
	clSetKernelArg(*(m_searchKernel),0, 8, m_searchBuffer); // Supply output buffer to kernel.
	clSetKernelArg(*(m_searchKernel),1, 8, m_searchBuffer);       // Supply header buffer to kernel.
	clSetKernelArg(*(m_searchKernel),2, 8, m_dag);       // Supply DAG buffer to kernel.
	clSetKernelArg(*(m_searchKernel),3, 4, dag_size);
	clSetKernelArg(*(m_searchKernel),4, 8, startNonce);
	clSetKernelArg(*(m_searchKernel),5, 8, target);
	*(err+errorCount)=clFinish(commandQueue);
	print_errors("hash\0",1,err);
}*/

#ifdef PARTITIONING
#endif

#ifdef API
#endif

#ifdef NETWORKING
#endif

#ifdef FAN
#endif

#ifdef TEMP
#endif

#ifdef OVERCLOCKING
#endif

#ifdef OVERVOLTING
#endif

void print_errors(char *section, int errorCount, cl_int *err)
{
#ifdef DEBUG
	int d=0;
	while(*(section+d) != '\0')
	{
		printf("%c",*(section+d));
		d++;
	}
	
	for(d=0; d< errorCount; d++)
	{
		printf(" %d",*(err+d));
	}printf("\n");
#endif
}
